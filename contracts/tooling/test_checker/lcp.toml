schemaVersion = "2.0"
id = "lcod://contract/tooling/test_checker@1.0.0"
version = "1.0.0"
kind = "contract"
summary = "Execute a compose with an input and validate the output against an expected value."

[inputs.input]
summary = "State injected before running the compose."
required = false
schema = """{
  "type": "object",
  "description": "Initial state passed to the compose.",
  "additionalProperties": true
}"""

[inputs.compose]
summary = "Inline compose definition to execute."
required = false
schema = """{
  "type": "array",
  "description": "Compose steps executed by the checker.",
  "items": { "type": "object" }
}"""

[inputs.composeRef]
summary = "Reference to an on-disk compose when `compose` is omitted."
required = false
schema = """{
  "type": "object",
  "description": "Path to a compose.yaml file to execute.",
  "properties": {
    "path": { "type": "string" }
  },
  "required": ["path"]
}"""

[inputs.expected]
summary = "Expected output payload."
required = true
schema = """{}"""

[inputs.bindings]
summary = "Optional bindings overrides applied before execution."
required = false
schema = """{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "contract": { "type": "string" },
      "implementation": { "type": "string" }
    },
    "required": ["contract", "implementation"]
  }
}"""

[inputs.streams]
summary = "Synthetic streams registered before running the compose."
required = false
schema = """{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "target": { "type": "string" },
      "chunks": {
        "type": "array",
        "items": { "type": "string" }
      },
      "encoding": { "type": "string" }
    },
    "required": ["target", "chunks"]
  }
}"""

[inputs.failFast]
summary = "When false, collect all diffs instead of stopping at the first mismatch."
required = false
schema = """{ "type": "boolean" }"""

[outputs.success]
summary = "Whether the actual output matched the expectation."
schema = """{ "type": "boolean" }"""

[outputs.actual]
summary = "Actual output returned by the compose."
schema = """{}"""

[outputs.expected]
summary = "Mirror of the expected payload for convenience."
schema = """{}"""

[outputs.durationMs]
summary = "Execution time in milliseconds."
schema = """{ "type": "number" }"""

[outputs.messages]
summary = "Diagnostic messages collected during execution."
schema = """{
  "type": "array",
  "items": { "type": "string" }
}"""

[outputs.diffs]
summary = "Optional diff information when the assertion fails."
schema = """{
  "type": "array",
  "items": { "type": "object" }
}"""

[documentation]
body = """
A generic harness contract that executes a target compose and validates its
output against an expected payload. Runtime implementations are responsible for
loading the compose, running it with the supplied input, and returning a
structured report.

## Responsibilities of the host runtime

- Resolve the compose definition either from the inline `compose` field or by
  loading the file pointed to by `composeRef.path`.
- Execute the compose with the provided `input` value. The compose is evaluated
  in the same environment as any other user flow: bindings, slots, and contracts
  should behave identically.
- Compare the compose result with the `expected` value. Implementations may
  perform deep equality or provide richer diffing, but the final `success` flag
  must reflect the comparison outcome.
- Populate the response with the actual output and any optional diagnostic data
  (`diff`, `messages`, etc.).

## Suggested behaviour

- `bindings`, `axioms` and `overrides` fields allow the caller to tweak the
  registry or provide mock implementations before executing the compose.
- `streams` lets callers describe synthetic stream handles (chunks + encoding)
  that the runtime should register and inject at specific paths in the initial
  state before execution.
- When `failFast` is `false`, implementations may collect multiple assertion
  failures and return them in the `messages` array.
- Runtimes are encouraged to attach metadata such as execution time or kernel
  version to ease cross-runtime comparisons.

The contract is intentionally minimal so that different kernels (Node, Rust,
...) can consume the same spec fixtures and report consistent results."""
