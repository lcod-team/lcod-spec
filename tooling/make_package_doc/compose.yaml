compose:
  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value:
        packageDescriptorPath: $.packageDescriptorPath
        componentsDir: $.componentsDir
        readmePath: $.readmePath
        write: $.write
        generateComponentDocs: $.generateComponentDocs
      fallback:
        write: true
        generateComponentDocs: true
    out:
      params: resolved

  - call: lcod://contract/core/fs/read_file@1
    in:
      path: $.params.packageDescriptorPath
      encoding: "utf-8"
    out:
      packageDescriptorText: data

  - call: lcod://contract/core/parse/toml@1
    in:
      text: $.packageDescriptorText
    out:
      packageDescriptor: value

  - call: lcod://tooling/path/dirname@0.1.0
    in:
      path: $.params.packageDescriptorPath
    out:
      packageRoot: dirname

  - call: lcod://tooling/script@1
    in:
      params: $.params
      packageRoot: $.packageRoot
      descriptor: $.packageDescriptor
      descriptorPath: $.params.packageDescriptorPath
      source: |
        async ({ state }) => {
          const toPosix = (value) => String(value || '').replace(/\\/g, '/');
          const isAbsolute = (value) => /^[a-zA-Z]:[\\/]/.test(value) || value?.startsWith('/');
          const joinPath = (base, relative) => {
            const baseClean = toPosix(base).replace(/\/+$/, '');
            const relClean = toPosix(relative).replace(/^\/+/, '');
            if (!baseClean) return relClean;
            if (!relClean) return baseClean;
            return `${baseClean}/${relClean}`;
          };
          const selectPath = (override, hint, fallback, base) => {
            let candidate = typeof override === 'string' ? override.trim() : '';
            if (!candidate && typeof hint === 'string') {
              candidate = hint.trim();
            }
            if (candidate) {
              if (candidate.startsWith('file://')) {
                return candidate;
              }
              if (isAbsolute(candidate)) {
                return toPosix(candidate);
              }
              return joinPath(base, candidate);
            }
            if (fallback) {
              return joinPath(base, fallback);
            }
            return '';
          };

          const params = state.params || {};
          const descriptor = state.descriptor && typeof state.descriptor === 'object'
            ? state.descriptor
            : {};
          const workspace = descriptor.workspace && typeof descriptor.workspace === 'object'
            ? descriptor.workspace
            : {};
          const packageRoot = toPosix(state.packageRoot || '');
          const descriptorPath = toPosix(params.packageDescriptorPath || state.descriptorPath || '');

          const componentsDir = selectPath(
            params.componentsDir,
            workspace.componentsDir,
            'components',
            packageRoot
          );
          const readmePath = selectPath(
            params.readmePath,
            workspace.readmePath,
            'README.md',
            packageRoot
          );

          return {
            resolvedPaths: {
              descriptorPath,
              packageRoot,
              componentsDir,
              readmePath
            },
            workspaceHints: {
              componentsDir: typeof workspace.componentsDir === 'string' ? workspace.componentsDir : '',
              readmePath: typeof workspace.readmePath === 'string' ? workspace.readmePath : ''
            }
          };
        }
    out:
      resolvedPaths: resolvedPaths
      workspaceHints: workspaceHints

  - call: lcod://contract/core/fs/list_dir@1
    in:
      path: $.resolvedPaths.componentsDir
      recursive: true
      pattern: "**/lcp.toml"
    out:
      componentEntries: entries

  - call: lcod://tooling/value/default_array@0.1.0
    in:
      value: $.componentEntries
      fallback: []
    out:
      componentEntries: resolved

  - call: lcod://tooling/script@1
    in:
      descriptorPath: $.resolvedPaths.descriptorPath
      packageDescriptor: $.packageDescriptor
      packageRoot: $.resolvedPaths.packageRoot
      componentsDir: $.resolvedPaths.componentsDir
      readmePath: $.resolvedPaths.readmePath
      entries: $.componentEntries
      params: $.params
      source: |
        async ({ state }, api) => {
          const toPosix = (value) => String(value || '').replace(/\\/g, '/');
          const encodeIconId = (iconId) => {
            if (typeof iconId !== 'string') return '';
            const trimmed = iconId.trim();
            if (!trimmed) return '';
            return trimmed
              .split(':')
              .map((part) => encodeURIComponent(part.trim()))
              .join(':');
          };

          const entries = Array.isArray(state.entries) ? state.entries.slice() : [];
          const params = state.params || {};
          const packageRoot = toPosix(state.packageRoot || '');
          const shouldGenerateDocs = params.generateComponentDocs !== false;
          const records = [];

          entries.sort((a, b) => {
            const aPath = toPosix(a && a.path ? a.path : '');
            const bPath = toPosix(b && b.path ? b.path : '');
            return aPath.localeCompare(bPath);
          });

          for (const entry of entries) {
            if (!entry || entry.type !== 'file') continue;
            const name = typeof entry.name === 'string' ? entry.name.toLowerCase() : '';
            if (name !== 'lcp.toml') continue;

            const descriptorPath = entry.path;
            const readResult = await api.call('lcod://contract/core/fs/read_file@1', {
              path: descriptorPath,
              encoding: 'utf-8'
            });
            if (!readResult || typeof readResult.data !== 'string') continue;

            const parsed = await api.call('lcod://contract/core/parse/toml@1', {
              text: readResult.data
            });
            const descriptor = parsed && parsed.value ? parsed.value : {};

            let artifacts = {};
            if (shouldGenerateDocs) {
              artifacts = await api.call('lcod://tooling/component/build_artifacts@0.1.0', {
                descriptorPath,
                write: params.write !== false
              });
            }

            const relPath = descriptorPath.startsWith(packageRoot)
              ? toPosix(descriptorPath.slice(packageRoot.length)).replace(/^\/+/, '')
              : toPosix(descriptorPath);
            const readmePath = artifacts && artifacts.readmePath
              ? toPosix(artifacts.readmePath)
              : '';
            const readmeRelative = readmePath && packageRoot && readmePath.startsWith(packageRoot)
              ? readmePath.slice(packageRoot.length).replace(/^\/+/, '')
              : readmePath;
            const iconId = descriptor.palette && typeof descriptor.palette.icon === 'string'
              ? descriptor.palette.icon.trim()
              : '';
            const encodedIcon = encodeIconId(iconId);
            const iconUrl = encodedIcon
              ? `https://api.iconify.design/${encodedIcon}.svg?height=32&width=32`
              : '';
            const iconAlt = iconId || descriptor.summary || descriptor.id || '';

            records.push({
              id: descriptor.id || '',
              version: descriptor.version || '',
              summary: descriptor.summary || '',
              descriptorPath: toPosix(descriptorPath),
              relativePath: relPath,
              readmePath,
              readmeRelative,
              inputSchemaPath: artifacts.inputSchemaPath || '',
              outputSchemaPath: artifacts.outputSchemaPath || '',
              generated: Boolean(artifacts && artifacts.readme),
              icon: iconId,
              iconUrl,
              iconAlt
            });
          }

          return { records };
        }
    out:
      componentRecords: records

  - call: lcod://tooling/script@1
    in:
      descriptor: $.packageDescriptor
      components: $.componentRecords
      params: $.params
      source: |
        async ({ state }) => {
          const HEADER = '<!-- AUTO-GENERATED: edit lcp.toml and run scripts/build-component-artifacts.mjs -->';
          const toPosix = (value) => String(value || '').replace(/\\/g, '/');
          const encodeIconId = (iconId) => {
            if (typeof iconId !== 'string') return '';
            const trimmed = iconId.trim();
            if (!trimmed) return '';
            return trimmed
              .split(':')
              .map((part) => encodeURIComponent(part.trim()))
              .join(':');
          };
          const escapeAttribute = (value) => String(value || '').replace(/"/g, '&quot;');

          const descriptor = state.descriptor && typeof state.descriptor === 'object'
            ? state.descriptor
            : {};
          const components = Array.isArray(state.components) ? state.components.slice() : [];

          const kind = typeof descriptor.kind === 'string' ? descriptor.kind.trim() : '';
          if (kind && kind !== 'workspace-package') {
            throw new Error(
              `tooling.make_package_doc: expected descriptor.kind = "workspace-package", received "${kind || 'unknown'}"`
            );
          }

          components.sort((a, b) => {
            const byId = String(a && a.id ? a.id : '').localeCompare(String(b && b.id ? b.id : ''));
            if (byId !== 0) return byId;
            return toPosix(a && a.relativePath ? a.relativePath : '')
              .localeCompare(toPosix(b && b.relativePath ? b.relativePath : ''));
          });

          const packageIconId = descriptor.palette && typeof descriptor.palette.icon === 'string'
            ? descriptor.palette.icon.trim()
            : '';
          const packageIconUrl = packageIconId ? encodeIconId(packageIconId) : '';
          const packageIconTag = packageIconUrl
            ? `<p><img src="https://api.iconify.design/${packageIconUrl}.svg?height=64&width=64" alt="${escapeAttribute(descriptor.summary || descriptor.id || 'Package icon')}" width="64" height="64" /></p>`
            : '';

          const lines = [HEADER];
          if (packageIconTag) {
            lines.push(packageIconTag);
          }

          const title = descriptor.id || '(missing id)';
          lines.push(`# ${title}`);

          if (descriptor.summary) {
            lines.push('');
            lines.push(String(descriptor.summary).trim());
          }

          if (components.length) {
            lines.push('');
            lines.push('## Components', '');
            lines.push('| Icon | Component | Summary | Docs |');
            lines.push('| --- | --- | --- | --- |');
            for (const entry of components) {
              const iconHtml = entry.iconUrl
                ? `<img src="${entry.iconUrl}" alt="${escapeAttribute(entry.iconAlt || '')}" width="32" height="32" />`
                : '`-`';
              const docLinkTarget = entry.readmeRelative
                || entry.readmePath
                || entry.relativePath
                || '';
              const docsCell = docLinkTarget
                ? `[README](${docLinkTarget})`
                : '`-`';
              const componentTarget = entry.readmeRelative
                || entry.relativePath
                || entry.readmePath
                || '';
              const componentCell = entry.id
                ? (componentTarget ? `[\\\`${entry.id}\\\`](${componentTarget})` : `\`${entry.id}\``)
                : '`(missing id)`';
              const summary = entry.summary ? String(entry.summary).replace(/\|/g, '\\|') : '';
              lines.push(`| ${iconHtml} | ${componentCell} | ${summary} | ${docsCell} |`);
            }
            lines.push('');
          } else {
            lines.push('');
            lines.push('## Components', '', '_No component descriptors found in this package._', '');
          }

          return { readme: lines.join('\n').trimEnd() + '\n' };
        }
    out:
      packageReadme: readme

  - call: lcod://flow/if@1
    in:
      cond: $.params.write
    slots:
      then:
        - call: lcod://contract/core/fs/write_file@1
          in:
            path: $.resolvedPaths.readmePath
            data: $.packageReadme
            encoding: "utf-8"
            createParents: true
          out:
            writeResult: $
    out:
      readmeWriteResult: writeResult

  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.readmeWriteResult
      fallback: {}
    out:
      readmeWriteResult: resolved

  - call: lcod://impl/set@1
    in:
      descriptor: $.packageDescriptor
      components: $.componentRecords
      readme: $.packageReadme
      readmePath: $.resolvedPaths.readmePath
      readmeWriteResult: $.readmeWriteResult
    out:
      descriptor: descriptor
      components: components
      readme: readme
      readmePath: readmePath
      readmeWriteResult: readmeWriteResult
