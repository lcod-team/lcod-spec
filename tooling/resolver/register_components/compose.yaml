compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state, imports }) => {
          const specRoot = typeof state.specRoot === 'string' && state.specRoot.length > 0
            ? state.specRoot
            : null;
          const warnings = [];
          if (!specRoot) {
            warnings.push('resolver/register_components: specRoot is missing');
            return { components: [], warnings };
          }

          const definitions = [
            { id: 'lcod://tooling/registry/source/load@0.1.0', path: 'tooling/registry/source/compose.yaml' },
            { id: 'lcod://tooling/registry/index@0.1.0', path: 'tooling/registry/index/compose.yaml' },
            { id: 'lcod://tooling/registry/select@0.1.0', path: 'tooling/registry/select/compose.yaml' },
            { id: 'lcod://tooling/registry/resolution@0.1.0', path: 'tooling/registry/resolution/compose.yaml' },
            { id: 'lcod://tooling/resolver/warnings/merge@0.1.0', path: 'tooling/resolver/warnings/compose.yaml' },
            { id: 'lcod://tooling/resolver/context/prepare@0.1.0', path: 'tooling/resolver/context/compose.yaml' },
            { id: 'lcod://tooling/resolver/replace/apply@0.1.0', path: 'tooling/resolver/replace/compose.yaml' }
          ];

          const components = [];
          for (const def of definitions) {
            try {
              const { path } = await imports.pathJoin({ base: specRoot, segment: def.path });
              components.push({ id: def.id, composePath: path });
            } catch (err) {
              warnings.push(`resolver/register_components: failed to resolve ${def.id}: ${err.message}`);
            }
          }

          return { components, warnings };
        }
      input:
        specRoot: $.specRoot
      imports:
        pathJoin: lcod://axiom/path/join@1
    out:
      components: components
      buildWarnings: warnings

  - call: lcod://tooling/resolver/register@1
    in:
      components: $.components
    out:
      registered: registered
      registerWarnings: warnings

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const warnings = [];
          const collect = (items) => {
            if (!Array.isArray(items)) return;
            for (const item of items) {
              if (typeof item === 'string' && item.length > 0) {
                warnings.push(item);
              }
            }
          };
          collect(state.buildWarnings);
          collect(state.registerWarnings);
          return {
            registered: Number.isFinite(state.registered) ? state.registered : 0,
            warnings
          };
        }
      input:
        registered: $.registered
        buildWarnings: $.buildWarnings
        registerWarnings: $.registerWarnings
    out:
      registered: registered
      warnings: warnings
