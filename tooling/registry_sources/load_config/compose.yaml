compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { imports }) => {
          const ensureString = (value) => (typeof value === 'string' && value.length ? value : null);
          const ensureObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
          const isAbsolutePath = (value) => /^(?:[A-Za-z]:[\\/]|\/)/.test(value || '');

          const joinPaths = async (...segments) => {
            if (!segments.length) return '';
            let current = segments[0];
            for (let i = 1; i < segments.length; i += 1) {
              const segment = segments[i];
              if (segment == null) continue;
              const joined = await imports.pathJoin({ base: current, segment });
              current = joined?.path ?? current;
            }
            return current;
          };

          const dirname = async (target) => {
            const parent = await imports.pathJoin({ base: target, segment: '..' });
            return parent?.path ?? target;
          };

          const warnings = [];
          const builtinDefault = {
            schema: 'lcod-resolver/sources@1',
            sources: [
              {
                id: 'lcod-registry',
                priority: 50,
                entrypoint: {
                  type: 'https',
                  url: 'https://raw.githubusercontent.com/lcod-team/lcod-registry/main/catalogues.json'
                }
              }
            ]
          };

          const projectRoot = ensureString(state.projectRoot) || '.';
          const explicitSourcesPath = ensureString(state.sourcesPath);

          let resolvedSourcesPath;
          if (explicitSourcesPath) {
            resolvedSourcesPath = isAbsolutePath(explicitSourcesPath)
              ? explicitSourcesPath
              : await joinPaths(projectRoot, explicitSourcesPath);
          } else {
            resolvedSourcesPath = await joinPaths(projectRoot, 'sources.json');
          }

          let sourcesText = ensureString(state.sourcesText);
          let defaultSpec = ensureObject(state.defaultSourcesSpec);
          if (!defaultSpec || Object.keys(defaultSpec).length === 0) {
            defaultSpec = builtinDefault;
          }
          if (!sourcesText) {
            try {
              const result = await imports.fsReadFile({ path: resolvedSourcesPath, encoding: 'utf-8' });
              sourcesText = result?.data ?? null;
            } catch (err) {
              warnings.push(`sources.json missing at ${resolvedSourcesPath}; falling back to default registry catalogue (lcod-registry). (${err?.message || err})`);
              resolvedSourcesPath = 'builtin:default';
              sourcesText = JSON.stringify(defaultSpec);
            }
          }

          let sourcesConfig = null;
          let valid = false;
          try {
            sourcesConfig = JSON.parse(sourcesText);
            valid = true;
          } catch (err) {
            warnings.push(`Invalid sources.json: ${err.message}`);
            sourcesConfig = JSON.parse(JSON.stringify(defaultSpec));
            valid = true;
            resolvedSourcesPath = 'builtin:default';
          }

          const ensureSourcesArray = (config) => {
            if (!config || typeof config !== 'object') return JSON.parse(JSON.stringify(defaultSpec));
            const next = { ...config };
            if (!Array.isArray(next.sources) || next.sources.length === 0) {
              next.sources = JSON.parse(JSON.stringify(defaultSpec.sources));
              if (typeof next.schema !== 'string' || !next.schema.length) {
                next.schema = defaultSpec.schema;
              }
              warnings.push('sources.json has no sources entries; using default lcod-registry catalogue.');
            }
            return next;
          };

          if (valid) {
            sourcesConfig = ensureSourcesArray(sourcesConfig);
          }

          const sourcesBaseDir = resolvedSourcesPath === 'builtin:default'
            ? projectRoot
            : await dirname(resolvedSourcesPath);

          return {
            sourcesConfig,
            sourcesPath: resolvedSourcesPath,
            sourcesBaseDir,
            warnings,
            valid
          };
        }
      input:
        projectRoot: $.projectRoot
        sourcesPath: $.sourcesPath
        sourcesText: $.sourcesText
        defaultSourcesSpec: $.defaultSourcesSpec
      imports:
        fsReadFile: lcod://contract/core/fs/read-file@1
        pathJoin: lcod://axiom/path/join@1
    out:
      sourcesConfig: sourcesConfig
      sourcesPath: sourcesPath
      sourcesBaseDir: sourcesBaseDir
      warnings: warnings
      valid: valid
