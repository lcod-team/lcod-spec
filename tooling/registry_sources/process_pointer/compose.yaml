compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { imports }) => {
          const ensureObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
          const ensureArray = (value) => (Array.isArray(value) ? value : []);
          const warnings = [];

          const isNonEmptyString = async (value) => {
            const res = await imports.isStringNonEmpty({ value });
            return !!res?.ok;
          };
          const ensureString = async (value) => (await isNonEmptyString(value)) ? String(value) : null;

          const pointer = ensureObject(state.pointer) || {};
          const downloadsRoot = (await ensureString(state.downloadsRoot)) || '.';
          const defaultEntrypoint = ensureObject(state.defaultEntrypoint) || {};
          const basePriority = Number.isFinite(state.basePriority) ? Math.trunc(state.basePriority) : null;

          const joinChain = async (base, ...segments) => {
            const res = await imports.joinChain({ base, segments });
            return res?.path ?? base ?? '';
          };

          const dirname = async (value) => {
            const res = await imports.dirname({ path: value });
            return res?.dirname ?? value;
          };

          const resolveAbsolute = async (base, value) => {
            if (!value) return null;
            if (value.startsWith('file://')) return value.slice('file://'.length);
            const absolute = await imports.isAbsolute({ path: value });
            if (absolute?.absolute) return value;
            return await joinChain(base, value);
          };

          const pointerHashKey = async (payload) => {
            const digest = await imports.sha256({ data: JSON.stringify(payload) });
            const hex = digest?.hex?.trim();
            return hex && hex.length ? hex : `${Date.now()}${Math.random().toString(16).slice(2)}`;
          };

          const readUtf8 = async (filePath) => {
            const res = await imports.fsReadFile({ path: filePath, encoding: 'utf-8' });
            return res?.data ?? null;
          };

          const fetchEntrypoint = async () => {
            const entrypoint = ensureObject(pointer.entrypoint) || {};
            const kindRaw = await ensureString(entrypoint.type);
            const kind = kindRaw ? kindRaw.toLowerCase() : 'https';

            if (kind === 'file') {
              const rawPath = await ensureString(entrypoint.path);
              if (!rawPath) throw new Error('file entrypoint is missing path');
              const baseDirHint = await ensureString(pointer.catalogueBaseDir);
              const effectiveBase = baseDirHint || pointer.baseDir || '.';
              const absolutePath = await resolveAbsolute(effectiveBase, rawPath);
              const readCatalogue = async (pathCandidate) => {
                if (!pathCandidate) throw new Error('Unable to resolve file path for catalogue pointer');
                const text = await readUtf8(pathCandidate);
                const baseDir = await dirname(pathCandidate);
                return { text, baseDir, originPath: pathCandidate };
              };
              try {
                return await readCatalogue(absolutePath);
              } catch (error) {
                const fallbackBase = pointer.baseDir && pointer.baseDir.length
                  ? await joinChain(pointer.baseDir, 'registry')
                  : null;
                if (fallbackBase && rawPath.startsWith('./')) {
                  try {
                    const fallbackPath = await resolveAbsolute(fallbackBase, rawPath);
                    return await readCatalogue(fallbackPath);
                  } catch (_) {
                    throw error;
                  }
                }
                throw error;
              }
            }

            if (kind === 'http' || kind === 'https') {
              const url = await ensureString(entrypoint.url);
              if (!url) throw new Error('http(s) entrypoint is missing url');
              const keyHex = await pointerHashKey({ url, query: entrypoint.query || null, method: entrypoint.method || null });
              const destFile = await joinChain(downloadsRoot, 'http', `${keyHex}.json`);
              const downloadInput = { url, path: destFile };
              const methodValue = await ensureString(entrypoint.method);
              if (methodValue) downloadInput.method = methodValue;
              if (entrypoint.headers && typeof entrypoint.headers === 'object' && !Array.isArray(entrypoint.headers)) downloadInput.headers = entrypoint.headers;
              if (entrypoint.query && typeof entrypoint.query === 'object' && !Array.isArray(entrypoint.query)) downloadInput.query = entrypoint.query;
              if (typeof entrypoint.timeoutMs === 'number') downloadInput.timeoutMs = entrypoint.timeoutMs;
              if (typeof entrypoint.followRedirects === 'boolean') downloadInput.followRedirects = entrypoint.followRedirects;
              if (Object.prototype.hasOwnProperty.call(entrypoint, 'body')) downloadInput.body = entrypoint.body;
              const bodyEncoding = await ensureString(entrypoint.bodyEncoding);
              if (bodyEncoding) downloadInput.bodyEncoding = bodyEncoding;
              await imports.httpDownload(downloadInput);
              const text = await readUtf8(destFile);
              const baseDir = await dirname(destFile);
              return { text, baseDir, originPath: destFile };
            }

            if (kind === 'git') {
              const url = await ensureString(entrypoint.url);
              if (!url) throw new Error('git entrypoint is missing url');
              const keyHex = await pointerHashKey({ url, ref: entrypoint.ref || null, commit: entrypoint.commit || null, subpath: entrypoint.subpath || null });
              const destDir = await joinChain(downloadsRoot, 'git', keyHex);
              const cloneInput = { url, dest: destDir };
              const commitValue = await ensureString(entrypoint.commit);
              const refValue = await ensureString(entrypoint.ref);
              const subpathValue = await ensureString(entrypoint.subpath);
              if (commitValue) cloneInput.ref = commitValue;
              else if (refValue) cloneInput.ref = refValue;
              if (subpathValue) cloneInput.subdir = subpathValue;
              const cloneMeta = await imports.gitClone(cloneInput);
              const pathValue = await ensureString(entrypoint.path);
              const pointerPath = pathValue ? await resolveAbsolute(cloneMeta.path, pathValue) : cloneMeta.path;
              const text = await readUtf8(pointerPath);
              const baseDir = await dirname(pointerPath);
              return { text, baseDir, originPath: pointerPath, commit: cloneMeta.commit || commitValue || null };
            }

            throw new Error(`Unsupported catalogue schema ${entrypoint.type || 'unknown'}`);
          };

          let payload;
          try {
            payload = await fetchEntrypoint();
          } catch (err) {
            warnings.push(`Failed to load catalogue for ${pointer.id || 'catalogue'}: ${err?.message || err}`);
            return { entry: null, children: [], warnings };
          }

          if (payload && typeof payload.baseDir === 'string' && payload.baseDir.length) {
            pointer.baseDir = payload.baseDir;
            pointer.catalogueBaseDir = payload.baseDir;
          }

          if (pointer.checksum) {
            const digest = await imports.sha256({ data: payload.text ?? '' });
            const payloadBase64 = digest?.base64 ? `sha256-${digest.base64}` : null;
            if (pointer.checksum && payloadBase64 && pointer.checksum !== payloadBase64) {
              warnings.push(`Checksum mismatch for ${pointer.id || 'catalogue'}: expected ${pointer.checksum}, got ${payloadBase64}`);
            }
          }

          let parsed = null;
          let parseError = null;
          try {
            parsed = JSON.parse(payload.text);
          } catch (err) {
            parseError = err;
          }

          let schema = null;
          if (parsed && typeof parsed === 'object' && parsed !== null) {
            schema = await ensureString(parsed.schema);
          }

          const children = [];
          let entry = null;

          if (schema === 'lcod-registry/catalogues@1') {
            const catalogues = ensureArray(parsed.catalogues);
            for (const childEntry of catalogues) {
              const normalized = await imports.normalizePointer({
                entry: childEntry,
                inherited: pointer,
                baseDir: payload.baseDir,
                sourcesBaseDir: payload.baseDir || pointer.baseDir || '.',
                defaultEntrypoint,
                basePriority,
                catalogueBaseDir: payload.baseDir
              });
              if (normalized?.warnings?.length) warnings.push(...normalized.warnings);
              if (normalized?.pointer) children.push(normalized.pointer);
            }
          } else if (schema === 'lcod-registry/catalogue@1') {
            const processed = await imports.processCatalogue({
              catalogue: parsed,
              pointer: pointer,
              basePriority,
              baseDir: payload.baseDir
            });
            if (processed?.warnings?.length) warnings.push(...processed.warnings);
            entry = processed?.entry || null;
          } else if (!schema) {
            const sourcePath = await ensureString(payload.originPath);
            let manifestEntries = null;
            if (sourcePath) {
              const readResult = await imports.readJsonl({ path: sourcePath, encoding: 'utf-8' });
              if (Array.isArray(readResult?.warnings)) warnings.push(...readResult.warnings);
              if (Array.isArray(readResult?.entries)) manifestEntries = readResult.entries;
            }
            if (!manifestEntries) {
              manifestEntries = [];
              const rawLines = typeof payload.text === 'string' ? payload.text.split(/\r?\n/) : [];
              for (const rawLine of rawLines) {
                const trimmed = rawLine.trim();
                if (!trimmed.length) continue;
                try {
                  manifestEntries.push(JSON.parse(trimmed));
                } catch (lineErr) {
                  warnings.push(`Failed to parse manifest line for ${pointer.id || 'catalogue'}: ${lineErr.message}`);
                }
              }
            }

            if (!manifestEntries.length) {
              const message = parseError ? parseError.message : 'empty manifest';
              warnings.push(`Invalid manifest payload for ${pointer.id || 'catalogue'}: ${message}`);
              return { entry: null, children: [], warnings };
            }

            const [rawHeader, ...rawEntries] = manifestEntries;
            const header = rawHeader && typeof rawHeader === 'object' ? rawHeader : null;
            if (!header || (typeof header.type !== 'string') || header.type.toLowerCase() !== 'manifest') {
              warnings.push(`JSONL manifest for ${pointer.id || 'catalogue'} is missing a manifest header`);
              return { entry: null, children: [], warnings };
            }

            const manifestId = typeof header.id === 'string' && header.id.length ? header.id : pointer.id || 'catalogue';
            const manifestPriority = Number.isFinite(header.priority) ? Math.trunc(header.priority) : pointer.priority ?? basePriority ?? null;
            const manifestDefaults = header.defaults && typeof header.defaults === 'object' && !Array.isArray(header.defaults) ? header.defaults : null;
            const manifestMetadata = header.metadata && typeof header.metadata === 'object' && !Array.isArray(header.metadata)
              ? header.metadata
              : pointer.metadata || null;

            const manifestLines = [];
            for (const raw of rawEntries) {
              if (!raw || typeof raw !== 'object') continue;
              const entryType = typeof raw.type === 'string' ? raw.type.toLowerCase() : null;
              if (entryType === 'component') {
                const componentId = typeof raw.id === 'string' && raw.id.length ? raw.id : null;
                if (!componentId) {
                  warnings.push(`JSONL manifest ${manifestId} skipped component without id`);
                  continue;
                }
                const line = {
                  kind: 'component',
                  id: componentId,
                  registryId: manifestId
                };
                if (typeof raw.version === 'string' && raw.version.length) line.version = raw.version;
                if (typeof raw.compose === 'string' && raw.compose.length) line.manifest = raw.compose;
                else if (typeof raw.manifest === 'string' && raw.manifest.length) line.manifest = raw.manifest;
                if (typeof raw.lcp === 'string' && raw.lcp.length) line.lcp = raw.lcp;
                if (typeof raw.url === 'string' && raw.url.length) line.url = raw.url;
                if (typeof raw.package === 'string' && raw.package.length) line.package = raw.package;
                if (typeof raw.namespace === 'string' && raw.namespace.length) line.namespace = raw.namespace;
                if (raw.metadata && typeof raw.metadata === 'object' && !Array.isArray(raw.metadata)) line.metadata = raw.metadata;
                if (raw.sha256) line.sha256 = raw.sha256;
                if (raw.integrity) line.integrity = raw.integrity;
                if (raw.artifact && typeof raw.artifact === 'object' && !Array.isArray(raw.artifact)) line.artifact = raw.artifact;
                if (Number.isFinite(raw.priority)) line.priority = Math.trunc(raw.priority);
                manifestLines.push(line);
              } else if (entryType === 'list') {
                const childEntry = {
                  id: typeof raw.id === 'string' && raw.id.length ? raw.id : manifestId,
                  priority: Number.isFinite(raw.priority) ? Math.trunc(raw.priority) : null,
                  metadata: raw.metadata && typeof raw.metadata === 'object' && !Array.isArray(raw.metadata) ? raw.metadata : null,
                  entrypoint: {}
                };
                if (typeof raw.url === 'string' && raw.url.length) {
                  childEntry.entrypoint.type = raw.url.startsWith('http:') ? 'http' : 'https';
                  childEntry.entrypoint.url = raw.url;
                }
                if (typeof raw.path === 'string' && raw.path.length) {
                  childEntry.entrypoint.type = 'file';
                  childEntry.entrypoint.path = raw.path;
                }
                if (!childEntry.entrypoint.type) {
                  warnings.push(`JSONL manifest ${manifestId} list entry is missing path or url`);
                  continue;
                }
                if (typeof raw.package === 'string' && raw.package.length) {
                  childEntry.metadata = childEntry.metadata || {};
                  childEntry.metadata.package = raw.package;
                }
                if (typeof raw.namespace === 'string' && raw.namespace.length) {
                  childEntry.metadata = childEntry.metadata || {};
                  childEntry.metadata.namespace = raw.namespace;
                }
                if (typeof raw.version === 'string' && raw.version.length) {
                  childEntry.metadata = childEntry.metadata || {};
                  childEntry.metadata.version = raw.version;
                }
                const normalized = await imports.normalizePointer({
                  entry: childEntry,
                  inherited: pointer,
                  baseDir: payload.baseDir,
                  sourcesBaseDir: payload.baseDir || pointer.baseDir || '.',
                  defaultEntrypoint,
                  basePriority,
                  catalogueBaseDir: payload.baseDir
                });
                if (normalized?.warnings?.length) warnings.push(...normalized.warnings);
                if (normalized?.pointer) children.push(normalized.pointer);
              } else if (entryType) {
                warnings.push(`JSONL manifest ${manifestId} encountered unsupported entry type ${entryType}`);
              }
            }

            entry = {
              id: manifestId,
              lines: manifestLines
            };
            if (Number.isFinite(manifestPriority)) entry.priority = manifestPriority;
            if (manifestDefaults) entry.defaults = manifestDefaults;
            if (manifestMetadata) entry.metadata = manifestMetadata;
          } else {
            warnings.push(`Unsupported catalogue schema ${schema || '<missing>'} for ${pointer.id || 'catalogue'}`);
          }

          const resolvedCommit = payload.commit || pointer.commit || null;
          return { entry, children, warnings, commit: resolvedCommit };
        }
      input:
        pointer: $.pointer
        downloadsRoot: $.downloadsRoot
        defaultEntrypoint: $.defaultEntrypoint
        basePriority: $.basePriority
      imports:
        fsReadFile: lcod://contract/core/fs/read-file@1
        gitClone: lcod://contract/core/git/clone@1
        httpDownload: lcod://axiom/http/download@1
        joinChain: lcod://tooling/path/join_chain@0.1.0
        dirname: lcod://tooling/path/dirname@0.1.0
        isAbsolute: lcod://tooling/path/is_absolute@0.1.0
        sha256: lcod://tooling/hash/sha256_base64@0.1.0
        normalizePointer: lcod://tooling/registry_sources/normalize_pointer@0.1.0
        processCatalogue: lcod://tooling/registry_sources/process_catalogue@0.1.0
        isStringNonEmpty: lcod://tooling/value/is_string_nonempty@0.1.0
        readJsonl: lcod://tooling/jsonl/read@0.1.0
    out:
      entry: entry
      children: children
      warnings: warnings
      commit: commit
      slots: children
