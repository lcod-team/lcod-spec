compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { imports }) => {
          const ensureObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
          const ensureArray = (value) => (Array.isArray(value) ? value : []);
          const warnings = [];

          const isNonEmptyString = async (value) => {
            const res = await imports.isStringNonEmpty({ value });
            return !!res?.ok;
          };
          const ensureString = async (value) => (await isNonEmptyString(value)) ? String(value) : null;

          const pointer = ensureObject(state.pointer) || {};
          const downloadsRoot = (await ensureString(state.downloadsRoot)) || '.';
          const defaultEntrypoint = ensureObject(state.defaultEntrypoint) || {};
          const basePriority = Number.isFinite(state.basePriority) ? Math.trunc(state.basePriority) : null;

          const joinChain = async (base, ...segments) => {
            const res = await imports.joinChain({ base, segments });
            return res?.path ?? base ?? '';
          };

          const dirname = async (value) => {
            const res = await imports.dirname({ path: value });
            return res?.dirname ?? value;
          };

          const resolveAbsolute = async (base, value) => {
            if (!value) return null;
            if (value.startsWith('file://')) return value.slice('file://'.length);
            const absolute = await imports.isAbsolute({ path: value });
            if (absolute?.absolute) return value;
            return await joinChain(base, value);
          };

          const pointerHashKey = async (payload) => {
            const digest = await imports.sha256({ data: JSON.stringify(payload) });
            const hex = digest?.hex?.trim();
            return hex && hex.length ? hex : `${Date.now()}${Math.random().toString(16).slice(2)}`;
          };

          const readUtf8 = async (filePath) => {
            const res = await imports.fsReadFile({ path: filePath, encoding: 'utf-8' });
            return res?.data ?? null;
          };

          const fetchEntrypoint = async () => {
            const entrypoint = ensureObject(pointer.entrypoint) || {};
            const kindRaw = await ensureString(entrypoint.type);
            const kind = kindRaw ? kindRaw.toLowerCase() : 'https';

            if (kind === 'file') {
              const rawPath = await ensureString(entrypoint.path);
              if (!rawPath) throw new Error('file entrypoint is missing path');
              const baseDirHint = await ensureString(pointer.catalogueBaseDir);
              const effectiveBase = baseDirHint || pointer.baseDir || '.';
              const absolutePath = await resolveAbsolute(effectiveBase, rawPath);
              if (!absolutePath) throw new Error('Unable to resolve file path for catalogue pointer');
              const text = await readUtf8(absolutePath);
              const baseDir = await dirname(absolutePath);
              return { text, baseDir, originPath: absolutePath };
            }

            if (kind === 'http' || kind === 'https') {
              const url = await ensureString(entrypoint.url);
              if (!url) throw new Error('http(s) entrypoint is missing url');
              const keyHex = await pointerHashKey({ url, query: entrypoint.query || null, method: entrypoint.method || null });
              const destFile = await joinChain(downloadsRoot, 'http', `${keyHex}.json`);
              const downloadInput = { url, path: destFile };
              const methodValue = await ensureString(entrypoint.method);
              if (methodValue) downloadInput.method = methodValue;
              if (entrypoint.headers && typeof entrypoint.headers === 'object' && !Array.isArray(entrypoint.headers)) downloadInput.headers = entrypoint.headers;
              if (entrypoint.query && typeof entrypoint.query === 'object' && !Array.isArray(entrypoint.query)) downloadInput.query = entrypoint.query;
              if (typeof entrypoint.timeoutMs === 'number') downloadInput.timeoutMs = entrypoint.timeoutMs;
              if (typeof entrypoint.followRedirects === 'boolean') downloadInput.followRedirects = entrypoint.followRedirects;
              if (Object.prototype.hasOwnProperty.call(entrypoint, 'body')) downloadInput.body = entrypoint.body;
              const bodyEncoding = await ensureString(entrypoint.bodyEncoding);
              if (bodyEncoding) downloadInput.bodyEncoding = bodyEncoding;
              await imports.httpDownload(downloadInput);
              const text = await readUtf8(destFile);
              const baseDir = await dirname(destFile);
              return { text, baseDir, originPath: destFile };
            }

            if (kind === 'git') {
              const url = await ensureString(entrypoint.url);
              if (!url) throw new Error('git entrypoint is missing url');
              const keyHex = await pointerHashKey({ url, ref: entrypoint.ref || null, commit: entrypoint.commit || null, subpath: entrypoint.subpath || null });
              const destDir = await joinChain(downloadsRoot, 'git', keyHex);
              const cloneInput = { url, dest: destDir };
              const commitValue = await ensureString(entrypoint.commit);
              const refValue = await ensureString(entrypoint.ref);
              const subpathValue = await ensureString(entrypoint.subpath);
              if (commitValue) cloneInput.ref = commitValue;
              else if (refValue) cloneInput.ref = refValue;
              if (subpathValue) cloneInput.subdir = subpathValue;
              const cloneMeta = await imports.gitClone(cloneInput);
              const pathValue = await ensureString(entrypoint.path);
              const pointerPath = pathValue ? await resolveAbsolute(cloneMeta.path, pathValue) : cloneMeta.path;
              const text = await readUtf8(pointerPath);
              const baseDir = await dirname(pointerPath);
              return { text, baseDir, originPath: pointerPath, commit: cloneMeta.commit || commitValue || null };
            }

            throw new Error(`Unsupported catalogue schema ${entrypoint.type || 'unknown'}`);
          };

          let payload;
          try {
            payload = await fetchEntrypoint();
          } catch (err) {
            warnings.push(`Failed to load catalogue for ${pointer.id || 'catalogue'}: ${err?.message || err}`);
            return { entry: null, children: [], warnings };
          }

          if (payload && typeof payload.baseDir === 'string' && payload.baseDir.length) {
            pointer.baseDir = payload.baseDir;
            pointer.catalogueBaseDir = payload.baseDir;
          }

          if (pointer.checksum) {
            const digest = await imports.sha256({ data: payload.text ?? '' });
            const payloadBase64 = digest?.base64 ? `sha256-${digest.base64}` : null;
            if (pointer.checksum && payloadBase64 && pointer.checksum !== payloadBase64) {
              warnings.push(`Checksum mismatch for ${pointer.id || 'catalogue'}: expected ${pointer.checksum}, got ${payloadBase64}`);
            }
          }

          let parsed;
          try {
            parsed = JSON.parse(payload.text);
          } catch (err) {
            warnings.push(`Invalid catalogue payload for ${pointer.id || 'catalogue'}: ${err.message}`);
            return { entry: null, children: [], warnings };
          }

          const schema = await ensureString(parsed.schema);
          const children = [];
          let entry = null;

          if (schema === 'lcod-registry/catalogues@1') {
            const catalogues = ensureArray(parsed.catalogues);
            for (const childEntry of catalogues) {
              const normalized = await imports.normalizePointer({
                entry: childEntry,
                inherited: pointer,
                baseDir: payload.baseDir,
                sourcesBaseDir: payload.baseDir || pointer.baseDir || '.',
                defaultEntrypoint,
                basePriority,
                catalogueBaseDir: payload.baseDir
              });
              if (normalized?.warnings?.length) warnings.push(...normalized.warnings);
              if (normalized?.pointer) children.push(normalized.pointer);
            }
          } else if (schema === 'lcod-registry/catalogue@1') {
            const processed = await imports.processCatalogue({
              catalogue: parsed,
              pointer: pointer,
              basePriority,
              baseDir: payload.baseDir
            });
            if (processed?.warnings?.length) warnings.push(...processed.warnings);
            entry = processed?.entry || null;
          } else {
            warnings.push(`Unsupported catalogue schema ${schema || '<missing>'} for ${pointer.id || 'catalogue'}`);
          }

          const resolvedCommit = payload.commit || pointer.commit || null;
          return { entry, children, warnings, commit: resolvedCommit };
        }
      input:
        pointer: $.pointer
        downloadsRoot: $.downloadsRoot
        defaultEntrypoint: $.defaultEntrypoint
        basePriority: $.basePriority
      imports:
        fsReadFile: lcod://contract/core/fs/read-file@1
        gitClone: lcod://contract/core/git/clone@1
        httpDownload: lcod://axiom/http/download@1
        joinChain: lcod://tooling/path/join_chain@0.1.0
        dirname: lcod://tooling/path/dirname@0.1.0
        isAbsolute: lcod://tooling/path/is_absolute@0.1.0
        sha256: lcod://tooling/hash/sha256_base64@0.1.0
        normalizePointer: lcod://tooling/registry_sources/normalize_pointer@0.1.0
        processCatalogue: lcod://tooling/registry_sources/process_catalogue@0.1.0
        isStringNonEmpty: lcod://tooling/value/is_string_nonempty@0.1.0
    out:
      entry: entry
      children: children
      warnings: warnings
      commit: commit
