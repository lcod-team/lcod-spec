compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { imports }) => {
          const ensureObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
          const warnings = [];

          const isNonEmptyString = async (value) => {
            const res = await imports.isStringNonEmpty({ value });
            return !!res?.ok;
          };
          const ensureString = async (value) => (await isNonEmptyString(value)) ? String(value) : null;

          const entry = ensureObject(state.entry) || {};
          const inherited = ensureObject(state.inherited) || null;
          const defaultEntrypoint = ensureObject(state.defaultEntrypoint) || {};
          const basePriority = Number.isFinite(state.basePriority) ? Math.trunc(state.basePriority) : null;

          const baseDirOverride = await ensureString(state.baseDir);
          const sourcesBaseDir = (await ensureString(state.sourcesBaseDir)) || '.';
          const inheritedBaseDir = inherited ? await ensureString(inherited.baseDir) : null;
          const baseDir = baseDirOverride || inheritedBaseDir || sourcesBaseDir;

          const pointer = {
            id: (await ensureString(entry.id)) || (await ensureString(inherited?.id)) || 'catalogue',
            priority: Number.isFinite(entry.priority) ? Math.trunc(entry.priority) : inherited?.priority ?? basePriority ?? null,
            checksum: (await ensureString(entry.checksum)) || (await ensureString(inherited?.checksum)) || null,
            signature: (await ensureString(entry.signature)) || (await ensureString(inherited?.signature)) || null,
            publicKey: (await ensureString(entry.publicKey)) || (await ensureString(inherited?.publicKey)) || null,
            metadata: entry.metadata || inherited?.metadata || null,
            entrypoint: {},
            transport: entry.transport || inherited?.transport || null,
            baseDir,
            commit: (await ensureString(inherited?.commit)) || null
          };

          const catalogueBaseDir = (await ensureString(entry.catalogueBaseDir)) || (await ensureString(state.catalogueBaseDir)) || null;
          if (catalogueBaseDir) {
            pointer.catalogueBaseDir = catalogueBaseDir;
          }

          const mergedEntrypoint = {
            ...defaultEntrypoint,
            ...(inherited?.entrypoint || {}),
            ...(entry.entrypoint || {}),
            type: entry.entrypoint?.type || inherited?.entrypoint?.type || entry.type || entry.kind || defaultEntrypoint.type
          };

          if (await isNonEmptyString(entry.path)) mergedEntrypoint.path = entry.path;
          if (await isNonEmptyString(entry.url)) mergedEntrypoint.url = entry.url;
          if (await isNonEmptyString(entry.method)) mergedEntrypoint.method = entry.method;
          if (entry.headers && typeof entry.headers === 'object' && !Array.isArray(entry.headers)) mergedEntrypoint.headers = entry.headers;
          if (entry.query && typeof entry.query === 'object' && !Array.isArray(entry.query)) mergedEntrypoint.query = entry.query;
          if (typeof entry.timeoutMs === 'number') mergedEntrypoint.timeoutMs = entry.timeoutMs;
          if (typeof entry.followRedirects === 'boolean') mergedEntrypoint.followRedirects = entry.followRedirects;
          if (Object.prototype.hasOwnProperty.call(entry, 'body')) mergedEntrypoint.body = entry.body;
          if (await isNonEmptyString(entry.bodyEncoding)) mergedEntrypoint.bodyEncoding = entry.bodyEncoding;
          if (await isNonEmptyString(entry.ref)) mergedEntrypoint.ref = entry.ref;
          if (await isNonEmptyString(entry.commit)) mergedEntrypoint.commit = entry.commit;
          if (await isNonEmptyString(entry.subpath)) mergedEntrypoint.subpath = entry.subpath;

          const kindRaw = await ensureString(mergedEntrypoint.type);
          const kind = kindRaw ? kindRaw.toLowerCase() : 'https';

          if (kind === 'file') {
            const rawPath = await ensureString(mergedEntrypoint.path);
            if (!rawPath) {
              warnings.push(`sources entry ${pointer.id} (file) is missing path`);
              return { pointer: null, warnings };
            }
            pointer.entrypoint = { type: 'file', path: rawPath };
          } else if (kind === 'http' || kind === 'https') {
            const url = await ensureString(mergedEntrypoint.url);
            if (!url) {
              warnings.push(`sources entry ${pointer.id} (${kind}) is missing url`);
              return { pointer: null, warnings };
            }
            pointer.entrypoint = {
              type: 'https',
              url,
              method: mergedEntrypoint.method,
              headers: mergedEntrypoint.headers,
              query: mergedEntrypoint.query,
              timeoutMs: mergedEntrypoint.timeoutMs,
              followRedirects: mergedEntrypoint.followRedirects,
              body: mergedEntrypoint.body,
              bodyEncoding: mergedEntrypoint.bodyEncoding
            };
          } else if (kind === 'git') {
            const url = await ensureString(mergedEntrypoint.url);
            if (!url) {
              warnings.push(`sources entry ${pointer.id} (git) is missing url`);
              return { pointer: null, warnings };
            }
            pointer.entrypoint = {
              type: 'git',
              url,
              ref: mergedEntrypoint.ref,
              commit: mergedEntrypoint.commit,
              subpath: mergedEntrypoint.subpath,
              path: mergedEntrypoint.path
            };
          } else {
            warnings.push(`sources entry ${pointer.id} declares unsupported type ${kind}`);
            return { pointer: null, warnings };
          }

          if (pointer.entrypoint.type === 'git' && pointer.entrypoint.commit) {
            pointer.commit = pointer.entrypoint.commit;
          } else if (!pointer.commit && await isNonEmptyString(entry.commit)) {
            pointer.commit = entry.commit;
          }

          return { pointer, warnings };
        }
      input:
        entry: $.entry
        inherited: $.inherited
        baseDir: $.baseDir
        sourcesBaseDir: $.sourcesBaseDir
        defaultEntrypoint: $.defaultEntrypoint
        basePriority: $.basePriority
        catalogueBaseDir: $.catalogueBaseDir
      imports:
        isStringNonEmpty: lcod://tooling/value/is_string_nonempty@0.1.0
    out:
      pointer: pointer
      warnings: warnings
