compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { ctx }) => {
          const queue = Array.isArray(state.items) ? [...state.items] : [];
          const visited = state.visited && typeof state.visited === 'object' && !Array.isArray(state.visited)
            ? { ...state.visited }
            : {};
          let accumulator = state.state && typeof state.state === 'object' && !Array.isArray(state.state)
            ? state.state
            : {};
          const warnings = [];
          const maxIterations = Number.isFinite(state.maxIterations) && state.maxIterations > 0
            ? Math.trunc(state.maxIterations)
            : Infinity;

          let iterations = 0;

          while (queue.length > 0) {
            if (iterations >= maxIterations) {
              throw new Error(`queue/bfs exceeded maxIterations (${maxIterations})`);
            }

            const item = queue.shift();
            const slotVars = {
              index: iterations,
              remaining: queue.length,
              visitedCount: Object.keys(visited).length
            };

            let key = null;
            if (typeof ctx.runSlot === 'function') {
              try {
                const keyCandidate = await ctx.runSlot('key', { item, state: accumulator }, slotVars);
                if (typeof keyCandidate === 'string' && keyCandidate.length > 0) {
                  key = keyCandidate;
                }
              } catch (err) {
                warnings.push(`queue/bfs key slot failed: ${err?.message || err}`);
              }
            }

            if (!key) {
              try {
                key = JSON.stringify(item);
              } catch (err) {
                key = `item:${iterations}`;
              }
            }

            if (visited[key]) {
              iterations += 1;
              continue;
            }
            visited[key] = true;

            let processResult = {};
            if (typeof ctx.runSlot === 'function') {
              try {
                processResult = await ctx.runSlot('process', { item, state: accumulator }, slotVars) || {};
              } catch (err) {
                throw err;
              }
            }

            if (processResult && Array.isArray(processResult.children)) {
              for (const child of processResult.children) {
                queue.push(child);
              }
            }

            if (processResult && processResult.state && typeof processResult.state === 'object' && !Array.isArray(processResult.state)) {
              accumulator = processResult.state;
            }

            if (processResult && Array.isArray(processResult.warnings)) {
              for (const warning of processResult.warnings) {
                if (typeof warning === 'string' && warning.length > 0) {
                  warnings.push(warning);
                }
              }
            }

            iterations += 1;
          }

          return {
            state: accumulator,
            visited,
            warnings,
            iterations
          };
        }
      input:
        items: $.items
        state: $.state
        maxIterations: $.maxIterations
        visited: $.visited
    out:
      state: state
      visited: visited
      warnings: warnings
      iterations: iterations
