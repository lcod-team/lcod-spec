compose:
  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value:
        descriptorPath: $.descriptorPath
        write: $.write
        readmePath: $.readmePath
        inputSchemaPath: $.inputSchemaPath
        outputSchemaPath: $.outputSchemaPath
    out:
      params: resolved

  - call: lcod://contract/core/fs/read_file@1
    in:
      path: $.params.descriptorPath
      encoding: "utf-8"
    out:
      descriptorText: data

  - call: lcod://contract/core/parse/toml@1
    in:
      text: $.descriptorText
      encoding: "utf-8"
    out:
      descriptor: value

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ bindings }) => {
          const HEADER = '<!-- AUTO-GENERATED: edit lcp.toml and run scripts/build-component-artifacts.mjs -->';

          const descriptor = bindings.descriptor;
          if (!descriptor || typeof descriptor !== 'object') {
            throw new Error('component.build_artifacts: descriptor must be an object');
          }

          const descriptorPath = String(bindings.descriptorPath || '');
          if (!descriptorPath) {
            throw new Error('component.build_artifacts: descriptorPath is required');
          }

          const write = bindings.write !== false;
          const overrides = bindings.overrides || {};

          const toPosix = (value) => String(value || '').replace(/\\/g, '/');

          const dirname = (value) => {
            const normalized = toPosix(value);
            const idx = normalized.lastIndexOf('/');
            if (idx === -1) {
              return '.';
            }
            if (idx === 0) {
              return '/';
            }
            return normalized.slice(0, idx);
          };

          const resolveRelative = (baseDir, relative) => {
            const rel = toPosix(relative || '');
            if (!rel) return '';
            if (rel.startsWith('/')) return rel.replace(/\/{2,}/g, '/');
            if (baseDir === '.' || baseDir === '') {
              return rel.replace(/\/{2,}/g, '/');
            }
            if (baseDir === '/') {
              return ('/' + rel).replace(/\/{2,}/g, '/');
            }
            return (toPosix(baseDir) + '/' + rel).replace(/\/{2,}/g, '/');
          };

          const descriptorDir = dirname(descriptorPath);

          const resolvePath = (override, relative, fallbackRelative) => {
            if (override && typeof override === 'string' && override.trim().length) {
              return toPosix(override.trim());
            }
            if (relative && typeof relative === 'string' && relative.trim().length) {
              return resolveRelative(descriptorDir, relative.trim());
            }
            if (fallbackRelative) {
              return resolveRelative(descriptorDir, fallbackRelative);
            }
            return '';
          };

          const readmePath = resolvePath(
            overrides.readmePath,
            null,
            'README.md'
          );

          const tool = descriptor.tool || {};
          const inputSchemaPath = resolvePath(
            overrides.inputSchemaPath,
            tool.inputSchema || '',
            ''
          );
          const outputSchemaPath = resolvePath(
            overrides.outputSchemaPath,
            tool.outputSchema || '',
            ''
          );

          const sortKeys = (obj) => Object.keys(obj || {}).sort((a, b) => a.localeCompare(b));

          const parseJsonFragment = (fragment, context) => {
            if (fragment === undefined || fragment === null || fragment === '') {
              return {};
            }
            if (typeof fragment === 'object') {
              return fragment;
            }
            if (typeof fragment !== 'string') {
              throw new Error(`${context}: schema must be a string or object`);
            }
            try {
              return JSON.parse(fragment);
            } catch (error) {
              throw new Error(`${context}: invalid JSON - ${error.message}`);
            }
          };

          const describeSchema = (schema) => {
            if (!schema || typeof schema !== 'object') return 'any';
            if (schema.title) return schema.title;
            if (Array.isArray(schema.enum)) {
              const preview = schema.enum.slice(0, 4).map((value) => JSON.stringify(value)).join(', ');
              return `enum(${preview}${schema.enum.length > 4 ? ', â€¦' : ''})`;
            }
            if (schema.const !== undefined) {
              return `const ${JSON.stringify(schema.const)}`;
            }
            const type = schema.type;
            if (!type) return 'any';
            if (Array.isArray(type)) {
              return type.join(' | ');
            }
            if (type === 'array' && schema.items) {
              return `array<${describeSchema(schema.items)}>`;
            }
            return type;
          };

          const renderTable = (headers, rows) => {
            if (!rows.length) return '';
            const headerLine = `| ${headers.join(' | ')} |`;
            const separator = `| ${headers.map(() => '---').join(' | ')} |`;
            const lines = rows.map((cols) => `| ${cols.join(' | ')} |`);
            return [headerLine, separator, ...lines].join('\n');
          };

          const normalizeMultiline = (value) => {
            if (!value) return '';
            return String(value).replace(/\r\n/g, '\n').trim();
          };

          const buildReadme = () => {
            const lines = [];
            lines.push(HEADER);
            lines.push(`# ${descriptor.id}`);
            lines.push('');
            if (descriptor.summary) {
              lines.push(descriptor.summary);
              lines.push('');
            }

            const inputKeys = sortKeys(descriptor.inputs);
            if (inputKeys.length) {
              const rows = inputKeys.map((key) => {
                const spec = descriptor.inputs[key] || {};
                const schemaObj = parseJsonFragment(spec.schema, `inputs.${key}.schema`);
                const type = describeSchema(schemaObj);
                const required = spec.required ? 'Yes' : 'No';
                const description = spec.summary || '';
                return [`\`${key}\``, type, required, description];
              });
              const table = renderTable(['Name', 'Type', 'Required', 'Description'], rows);
              if (table) {
                lines.push('## Inputs', '', table, '');
              }
            }

            const outputKeys = sortKeys(descriptor.outputs);
            if (outputKeys.length) {
              const rows = outputKeys.map((key) => {
                const spec = descriptor.outputs[key] || {};
                const schemaObj = parseJsonFragment(spec.schema, `outputs.${key}.schema`);
                const type = describeSchema(schemaObj);
                const description = spec.summary || '';
                return [`\`${key}\``, type, description];
              });
              const table = renderTable(['Name', 'Type', 'Description'], rows);
              if (table) {
                lines.push('## Outputs', '', table, '');
              }
            }

            const slotKeys = sortKeys(descriptor.slots);
            if (slotKeys.length) {
              lines.push('## Slots', '');
              for (const key of slotKeys) {
                const spec = descriptor.slots[key] || {};
                lines.push(`### ${key}`);
                if (spec.summary) {
                  lines.push(spec.summary);
                }
                if (spec.description) {
                  lines.push('', spec.description);
                }
                if (spec.schema) {
                  const schemaText = normalizeMultiline(spec.schema);
                  if (schemaText) {
                    lines.push('', '```json', schemaText, '```');
                  }
                }
                if (spec.example) {
                  const exampleText = normalizeMultiline(spec.example);
                  if (exampleText) {
                    lines.push('', '```yaml', exampleText, '```');
                  }
                }
                lines.push('');
              }
            }

            const docBody = normalizeMultiline(descriptor.documentation && descriptor.documentation.body);
            if (docBody) {
              lines.push('## Notes', '', docBody, '');
            }

            const content = lines.join('\n').replace(/\n{3,}/g, '\n\n').trimEnd();
            return content + '\n';
          };

          const parseExample = (value) => {
            if (value === undefined || value === null) return undefined;
            if (typeof value === 'string') {
              try {
                return JSON.parse(value);
              } catch {
                return value;
              }
            }
            return value;
          };

          const buildSchema = (entries, description) => {
            const schema = {
              $schema: 'https://json-schema.org/draft/2020-12/schema',
              type: 'object',
              additionalProperties: false,
              properties: {}
            };
            if (description) {
              schema.description = description;
            }
            const required = [];
            const keys = sortKeys(entries);
            for (const key of keys) {
              const spec = entries[key] || {};
              const fragment = parseJsonFragment(spec.schema, `${description || 'entry'}.${key}.schema`);
              const property = { ...fragment };
              if (spec.summary && !property.description) {
                property.description = spec.summary;
              }
              const singleExample = parseExample(spec.example);
              if (singleExample !== undefined) {
                property.examples = [singleExample];
              }
              const multipleExamples = Array.isArray(spec.examples) ? spec.examples.map(parseExample).filter((value) => value !== undefined) : [];
              if (multipleExamples.length) {
                property.examples = multipleExamples;
              }
              const defaultValue = parseExample(spec.default);
              if (defaultValue !== undefined) {
                property.default = defaultValue;
              }
              schema.properties[key] = property;
              if (spec.required) {
                required.push(key);
              }
            }
            if (required.length) {
              schema.required = required;
            }
            return schema;
          };

          const readme = buildReadme();
          const inputSchema = buildSchema(descriptor.inputs || {}, `Inputs for ${descriptor.id}`);
          const outputSchema = buildSchema(descriptor.outputs || {}, `Outputs for ${descriptor.id}`);

          const hasInputProps = Object.keys(inputSchema.properties || {}).length > 0;
          const hasOutputProps = Object.keys(outputSchema.properties || {}).length > 0;

          const inputSchemaJson = JSON.stringify(inputSchema, null, 2) + '\n';
          const outputSchemaJson = JSON.stringify(outputSchema, null, 2) + '\n';

          const writeReadme = write && readmePath.length > 0;
          const writeInputSchema = write && inputSchemaPath.length > 0 && hasInputProps;
          const writeOutputSchema = write && outputSchemaPath.length > 0 && hasOutputProps;

          return {
            descriptor,
            readme,
            inputSchema,
            outputSchema,
            readmePath,
            inputSchemaPath,
            outputSchemaPath,
            inputSchemaJson,
            outputSchemaJson,
            writeReadme,
            writeInputSchema,
            writeOutputSchema
          };
        }
      bindings:
        descriptor:
          path: $.descriptor
        descriptorPath:
          path: $.params.descriptorPath
        write:
          path: $.params.write
        overrides:
          path: $.params
    out:
      descriptor: descriptor
      readme: readme
      inputSchema: inputSchema
      outputSchema: outputSchema
      readmePath: readmePath
      inputSchemaPath: inputSchemaPath
      outputSchemaPath: outputSchemaPath
      inputSchemaJson: inputSchemaJson
      outputSchemaJson: outputSchemaJson
      writeReadme: writeReadme
      writeInputSchema: writeInputSchema
      writeOutputSchema: writeOutputSchema

  - call: lcod://flow/if@1
    in:
      cond: $.writeReadme
    slots:
      then:
        - call: lcod://contract/core/fs/write_file@1
          in:
            path: $.readmePath
            data: $.readme
            encoding: "utf-8"
            createParents: true
          out:
            writeResult: $
    out:
      readmeWriteResult: writeResult

  - call: lcod://flow/if@1
    in:
      cond: $.writeInputSchema
    slots:
      then:
        - call: lcod://contract/core/fs/write_file@1
          in:
            path: $.inputSchemaPath
            data: $.inputSchemaJson
            encoding: "utf-8"
            createParents: true
          out:
            writeResult: $
    out:
      inputSchemaWriteResult: writeResult

  - call: lcod://flow/if@1
    in:
      cond: $.writeOutputSchema
    slots:
      then:
        - call: lcod://contract/core/fs/write_file@1
          in:
            path: $.outputSchemaPath
            data: $.outputSchemaJson
            encoding: "utf-8"
            createParents: true
          out:
            writeResult: $
    out:
      outputSchemaWriteResult: writeResult

  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.readmeWriteResult
      fallback: {}
    out:
      readmeWriteResult: resolved

  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.inputSchemaWriteResult
      fallback: {}
    out:
      inputSchemaWriteResult: resolved

  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.outputSchemaWriteResult
      fallback: {}
    out:
      outputSchemaWriteResult: resolved
