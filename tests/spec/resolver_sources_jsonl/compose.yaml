compose:
  - call: lcod://tooling/test_checker@1
    in:
      compose:
        - call: lcod://tooling/script@1
          in:
            source: |
              async ({ state, imports }) => {
                const pathJoin = imports.pathJoin;
                const envGet = imports.envGet;

                const specRootResult = await envGet({ name: 'SPEC_REPO_PATH' });
                const specRoot = specRootResult && typeof specRootResult.value === 'string' && specRootResult.value.trim().length > 0
                  ? specRootResult.value
                  : state.cwd;

                const baseDir = (await pathJoin({ base: specRoot, segment: state.specRelativePath })).path;
                const project = await pathJoin({ base: baseDir, segment: state.fixtureRelativePath });
                const cache = await pathJoin({ base: baseDir, segment: '.cache' });
                const sources = await pathJoin({ base: project.path, segment: state.sourcesRelativePath });

                return {
                  projectPath: project.path,
                  cacheDir: cache.path,
                  sourcesPath: sources.path
                };
              }
            input:
              cwd: '.'
              specRelativePath: 'tests/spec/resolver_sources_jsonl'
              fixtureRelativePath: 'fixtures/jsonl'
              sourcesRelativePath: 'lcod.sources.jsonl'
            imports:
              pathJoin: lcod://axiom/path/join@1
              envGet: lcod://contract/core/env/get@1
          out:
            projectPath: projectPath
            cacheDir: cacheDir
            sourcesPath: sourcesPath

        - call: lcod://tooling/resolver/internal/load-sources@0.1.0
          in:
            projectPath: $.projectPath
            cacheDir: $.cacheDir
            sourcesPath: $.sourcesPath
          out:
            registrySources: registrySources
            warnings: warnings
            sourcesPath: sourcesPath

        - call: lcod://tooling/script@1
          in:
            source: |
              async ({ state, imports }) => {
                const makeSummary = (entry) => ({
                  id: entry.id,
                  defaults: entry.defaults || null,
                  packages: Array.from(new Set(
                      Array.isArray(entry.lines)
                        ? entry.lines
                            .filter((line) => line && line.kind === 'component')
                            .map((line) => `${line.id}@${line.version}`)
                        : []
                    )).sort()
                });

                const summary = Array.isArray(state.registrySources)
                  ? state.registrySources.map(makeSummary).sort((a, b) => a.id.localeCompare(b.id))
                  : [];

                const toFileUrl = (absolutePath) => {
                  const normalized = absolutePath.replace(/\\/g, '/');
                  return `file://${normalized.endsWith('/') ? normalized : `${normalized}/`}`;
                };

                const projectAbsolute = state.projectPath;
                const coreDir = (await imports.pathJoin({ base: projectAbsolute, segment: 'registry/manifests/core' })).path;
                const extraDir = (await imports.pathJoin({ base: projectAbsolute, segment: 'registry/manifests/extra' })).path;

                const expected = {
                  'fixture/core': {
                    packages: ['lcod://fixture/core@0.1.0'],
                    defaultsUrlSuffix: '/registry/manifests/core/'
                  },
                  'fixture/extra': {
                    packages: ['lcod://fixture/extra@1.0.0'],
                    defaultsUrlSuffix: '/registry/manifests/extra/'
                  }
                };

                const summaryMap = new Map(summary.map((item) => [item.id, item]));

                const expectedIds = Object.keys(expected);
                const allPackagesMatch = expectedIds.every((id) => {
                  const entry = summaryMap.get(id);
                  if (!entry) return false;
                  const expectedMeta = expected[id];
                  const packages = Array.isArray(entry.packages) ? entry.packages.slice().sort() : [];
                  const expectedPackages = expectedMeta.packages.slice().sort();
                  if (JSON.stringify(packages) !== JSON.stringify(expectedPackages)) return false;
                  const url = entry.defaults && entry.defaults.url ? entry.defaults.url.replace(/\\/g, '/') : null;
                  return typeof url === 'string' && url.endsWith(expectedMeta.defaultsUrlSuffix);
                });

                const noExtraEntries = summary.length === expectedIds.length;
                const success = allPackagesMatch && noExtraEntries && Array.isArray(state.warnings) && state.warnings.length === 0;

                return {
                  success,
                  summary,
                  expected,
                  warnings: state.warnings,
                  sourcesPath: state.sourcesPath
                };
              }
            input:
              registrySources: $.registrySources
              warnings: $.warnings
              projectPath: $.projectPath
              sourcesPath: $.sourcesPath
            imports:
              pathJoin: lcod://axiom/path/join@1
          out:
            success: success
            summary: summary
            expected: expected
            warnings: warnings
            sourcesPath: sourcesPath
      expected:
        success: true
    out:
      report: $
