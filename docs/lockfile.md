# Lockfile (`lcp.lock`)

The lockfile captures resolved component versions, sources, and bindings so that a project can be reproduced exactly.

## Location & format

- The lockfile resides alongside `lcp.toml` at the project root: `lcp.lock`.
- Format: TOML for readability and alignment with `lcp.toml`.
- `schema/lcp-lock.schema.json` defines the canonical structure used by validators.
- Generated by the resolver CLI (`lcod resolve` – TBD). Developers commit the lockfile in version control.

### Top-level structure

```toml
schemaVersion = "1.0"
projectId = "lcod://demo/my_project@0.1.0"  # optional
resolverVersion = "0.1.0"

[[components]]
id = "lcod://impl/net/fetch@1.0.0"
source = { type = "git", url = "https://github.com/lcod-registry/net-fetch.git", rev = "a1b2c3" }
integrity = "sha256-..."
path = "impl/net/fetch"  # optional relative path inside repo

[[components.bindings]]
contract = "lcod://contract/net/http-client@1"
implementation = "lcod://impl/net/fetch@1.0.0"

[[components.dependencies]]
id = "lcod://flow/foreach@1"
resolved = "lcod://flow/foreach@1.0.2"
source = { type = "registry", name = "lcod" }
```

## Fields

- `schemaVersion`: lockfile schema (starts at `1.0`).
- `projectId`: optional identifier for the project referencing this lock.
- `resolverVersion`: version of the resolver that produced the lock (helps detect incompatibilities).

### Components table

Each `[[components]]` entry represents a resolved component (implementation or flow) required by the project.

| Field           | Description |
|-----------------|-------------|
| `id`            | Canonical component ID requested (may be range or exact). |
| `resolved`      | (optional) Actual resolved ID if different from request (e.g. `@1` → `@1.0.3`). |
| `source`        | Object describing where the component was fetched (`type = git`, `registry`, `file`, etc.). |
| `integrity`     | Hash (e.g. `sha256-...`) of the package/archive. |
| `path`          | Optional subdirectory when the source hosts multiple components.
| `bindings`      | Optional array mapping contracts to implementations within this component.
| `dependencies`  | Optional array of transitive dependencies with their resolved versions.

### Source object

```
source = { type = "git", url = "https://github.com/org/repo.git", rev = "a1b2c3", subdir = "components/net/fetch" }
source = { type = "registry", name = "lcod", package = "impl/net/fetch", version = "1.0.0" }
source = { type = "file", path = "../local-components/fetch" }
```

Resolvers may add additional metadata (e.g. branch, registry endpoint). Unknown fields should be ignored by tooling.

## Lifecycle

1. Developer runs `lcod resolve` (or similar) to fetch dependencies.
2. Resolver writes `lcp.lock` with all resolved components.
3. Subsequent installs use the lockfile to fetch the exact same revisions.
4. When dependencies change, regenerate the lock (`lcod resolve --update`).

### Prototype script (spec examples)

For the examples in this repository, a simple helper is available:

```
node scripts/create-lock.cjs examples/demo/my_weather/lcp.toml
```

It generates a skeleton `lcp.lock` next to the descriptor, marking dependencies as `type = "path"`. Real projects will use the resolver to populate the full metadata.

## Interaction with `lcp.toml`

- `deps.requires` in `lcp.toml` lists constraints (e.g. `lcod://flow/foreach@1`).
- Lockfile records the exact versions (`lcod://flow/foreach@1.0.2`) and sources.
- Validators should ensure that every requirement has a matching entry in the lock and vice versa (optional for M2 initial version).

## Next steps

- Define resolver config (`lcod resolve` CLI, mirrors, replacements).
- Implement packing (`.lcpkg`) and integrity verification using the metadata stored in `lcp.lock`.
